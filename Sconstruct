#!python

# Overview of the build system
# - All global configurations goes in this file,
# - Each platforms created contains configurations and environment
# - Each project is called passing platforms.
# - For each platform one build will run, always in the 'build' folder.
# - Projects are expected to append data to platform enviroments when
#   necessary, such as includes, defines, libraries, etc.


#
# First we add our custom Functions to a default enviroment and configure it
import os
import fnmatch
default_env = Environment()

# Enable color terminal if available
if 'TERM' in os.environ.keys():
    default_env['ENV']['TERM'] = os.environ['TERM']

# Add a FindFiles function to help Programs to search for code
def FindFiles(self, path, glob):
    matches = []
    matches.extend(Glob(path + '/' + glob))
    matches.extend(Glob(path + '/*/' + glob))
    matches.extend(Glob(path + '/*/*/' + glob))
    matches.extend(Glob(path + '/*/*/*/' + glob))
    matches.extend(Glob(path + '/*/*/*/*/' + glob))
    matches.extend(Glob(path + '/*/*/*/*/*/' + glob))
    return matches
default_env.AddMethod(FindFiles)

# Transform a multiline string into a list of Files
def MultiLineStringToFiles(self, multiline_string):
    r = []
    for f in multiline_string.split('\n'):
        if len(f) > 0:
            r.append(File('./' + f))
    return r
default_env.AddMethod(MultiLineStringToFiles)

# Transform a list of C source into Objects
def SourceToObjects(self, source_list):
    r = []
    for s in source_list:
        s_path = s.path
        o_path = s_path.replace('.CPP', '.o').replace('.C', '.o').replace('.cpp', '.o').replace('.c', '.o')
        o = File('#' + o_path)
        r.append(o)
    return r
default_env.AddMethod(SourceToObjects)

# Transform a list of Objects into GCDA and GDNO
def ObjectsToGcov(self, source_list):
    r = []
    for s in source_list:
        s_path = s.path
        da_path = s_path.replace('.o', '.gcda')
        da = File('#' + da_path)
        no_path = s_path.replace('.o', '.gcno')
        no = File('#' + no_path)
        r.append(da)
        r.append(no)
    return r
default_env.AddMethod(ObjectsToGcov)


#
# Now we describe our platforms and configure its environments.
# `host_tests` Platform: Running tests on development computer
host_tests_plat = {
    'cpputest_extensions_enabled' : True,
    'coverage_excludes' : [],
    'env' : default_env.Clone (
            # We want lot's of warning on host_tests
            CXXFLAGS = ['-std=gnu++14', '-g3', '-O0', '-fno-inline', '-pthread',
                '-Wno-c++11-long-long', '-Wno-long-long', '-Wall', '-Wextra', '-Wshadow', '-Wswitch-default', '-Wswitch-enum',
                '-Wconversion', '-Wsign-conversion', '-Woverloaded-virtual', '-Wno-disabled-macro-expansion',
                '-Wno-padded', '-Wno-reserved-id-macro', '-Wno-keyword-macro', '-Wno-global-constructors',
                '-Wno-exit-time-destructors', '-Wno-weak-vtables', '-Wno-old-style-cast'],
            CFLAGS  = ['-std=gnu11', '-g3', '-O0', '-fno-inline',
                '-Wall', '-Wextra', '-Wswitch-default', '-Wswitch-enum', '-Wconversion', '-Wno-long-long'],
            LIBS = ['pthread'],
            CPPINCLUDES = []
    )
}

platforms = {'host_tests' : host_tests_plat}

# Build CppUTest libraries for each platforms
cpputest = SConscript('dependencies/cpputest/Sconscript', exports ='platforms')

# Enable GNU Coverage for the next builds on host_tests platform
host_tests_plat['env'].Append(
    CFLAGS = ['-fprofile-arcs', '-ftest-coverage'],
    CXXFLAGS = ['-fprofile-arcs', '-ftest-coverage'],
    LIBS = ['gcov']
)

# Build reacto as library
SConscript('reacto/Sconscript', exports ='platforms')


# Build reacto_tests executable
SConscript('reacto_tests/Sconscript', exports ='platforms')

#
#
# Tests Build
# Use `scons tests` during deveopment, to print tests results and force
# build of everything.
tests = Command( target = "tests",
                source = platforms['host_tests']['reacto_tests_executable'],
                action = "./$SOURCE -v | tee tests_report" )

Default(tests)

#
#
# Coverage Commands
#
# Re run test and store to file silently
tests_report_only = Command( target = "tests_report",
                source = platforms['host_tests']['reacto_tests_executable'],
                action = "./$SOURCE -v > ${TARGET}" )

# Generate .coverage.info for host_tests executables
Depends(
       Command( target = ".coverage.info.pre",
                source = [
                          platforms['host_tests']['reacto_build_dir'],
                          platforms['host_tests']['reacto_tests_build_dir']
                         ],
                action = "lcov -q --capture --directory ${SOURCES[0]} " \
                         "--ignore-errors=source " \
                         "--directory ${SOURCES[1]} " \
                         "--output-file $TARGET "
                         ),
       tests_report_only)

coverage_excludes = []
for name, plat in platforms.items():
    coverage_excludes.extend(plat['coverage_excludes'])
coverage_excludes.append("/usr/include/*")
coverage_excludes.append("dependencies/*")
coverage_excludes = " ".join(coverage_excludes)

lcov = Command( target = ".coverage.info",
                source = ".coverage.info.pre",
                action = "echo \"" \
                         + coverage_excludes +
                         "\" | xargs lcov -q --output-file $TARGET --remove $SOURCE && rm $SOURCE"
                         )


# Print and save coverage_report
coverage_report = Command( target = "coverage_report",
                           source = lcov,
                           action = "lcov --summary $SOURCE 2>&1 | tee $TARGET" )
Default(coverage_report)

# Generate html files for coverage
coverage_html = Command( target = "coverage",
                           source = lcov,
                           action = "genhtml -q $SOURCE --output-directory $TARGET" )

Clean('./', [coverage_html, coverage_report, lcov])
Clean ('./', "tests_report")
